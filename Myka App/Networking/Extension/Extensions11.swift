//
//  Extension.swift
//  DriverApp
//
//  Created by Devendra Agnihotri on 23/01/17.
//  Copyright Â© 2017 Devendra Agnihotri. All rights reserved.
//

import Foundation
import UIKit
import QuartzCore
import AVFoundation

/// Computed properties, based on the backing CALayer property, that are visible in Interface Builder.
extension UIView {
    
    /// When positive, the background of the layer will be drawn with rounded corners. Also effects the mask generated by the `masksToBounds' property. Defaults to zero. Animatable.
    @IBInspectable var cornerRadius: Double {
        get {
            return Double(self.layer.cornerRadius)
        }
        set {
            self.layer.cornerRadius = CGFloat(newValue)
        }
    }
    
    /// The width of the layer's border, inset from the layer bounds. The border is composited above the layer's content and sublayers and includes the effects of the `cornerRadius' property. Defaults to zero. Animatable.
    @IBInspectable var borderWidth: Double {
        get {
            return Double(self.layer.borderWidth)
        }
        set {
            self.layer.borderWidth = CGFloat(newValue)
        }
    }
    
    /// The color of the layer's border. Defaults to opaque black. Colors created from tiled patterns are supported. Animatable.
    @IBInspectable var borderColor: UIColor? {
        get {
            return UIColor(cgColor: self.layer.borderColor!)
        }
        set {
            self.layer.borderColor = newValue?.cgColor
        }
    }
    
    /// The color of the shadow. Defaults to opaque black. Colors created from patterns are currently NOT supported. Animatable.
    @IBInspectable var shadowColor: UIColor? {
        get {
            return UIColor(cgColor: self.layer.shadowColor!)
        }
        set {
            self.layer.shadowColor = newValue?.cgColor
        }
    }
    
    /// The opacity of the shadow. Defaults to 0. Specifying a value outside the [0,1] range will give undefined results. Animatable.
    @IBInspectable var shadowOpacity: Float {
        get {
            return self.layer.shadowOpacity
        }
        set {
            self.layer.shadowOpacity = newValue
        }
    }
    
    /// The shadow offset. Defaults to (0, -3). Animatable.
    @IBInspectable var shadowOffset: CGSize {
        get {
            return self.layer.shadowOffset
        }
        set {
            self.layer.shadowOffset = newValue
        }
    }
    
    /// The blur radius used to create the shadow. Defaults to 3. Animatable.
    @IBInspectable var shadowRadius: Double {
        get {
            return Double(self.layer.shadowRadius)
        }
        set {
            self.layer.shadowRadius = CGFloat(newValue)
        }
    }
    
//    @IBInspectable var shadowCornerRadius: CGFloat {
//            get {
//                return self.layer.cornerRadius
//            }
//            set {
//                self.layer.cornerRadius = newValue
//                self.layer.masksToBounds = false
//                self.layer.shadowPath = UIBezierPath(roundedRect: self.bounds, cornerRadius: newValue).cgPath
//            }
//        }
 
    
    @IBInspectable var topLeftRadius: CGFloat {
        get {
            return self.layer.cornerRadius
        }
        set {
            let maskPath1 = UIBezierPath(roundedRect: bounds, byRoundingCorners: [.topLeft], cornerRadii: CGSize(width: newValue, height: newValue))
            let maskLayer1 = CAShapeLayer()
            maskLayer1.frame = bounds
            maskLayer1.path = maskPath1.cgPath
            layer.mask = maskLayer1
        }
    }
   
    
    
}
extension UIImageView {
    
    @IBInspectable var ImageSet: Bool {
        get {
            return Bool(self.ImageSet)
        }
        set {
            let v = newValue
            if v {
//                self.pavan_tapToSeeFullImage()
            }
        }
    }
}
//#MARK: - Gradiont Color

extension UIView {
        func setGradientBackground(view: UIView, colorOne: UIColor, colorTwo: UIColor, colorThree: UIColor)  {
            let gradientlayer = CAGradientLayer()
            gradientlayer.frame = view.bounds
            gradientlayer.colors = [colorOne.cgColor, colorTwo.cgColor, colorThree.cgColor]
            //gradientlayer.cornerRadius = 15.0
            gradientlayer.locations = [0, 0.53, 1]
            gradientlayer.startPoint = CGPoint(x: 0.25, y: 0.5)
            gradientlayer.endPoint = CGPoint(x: 0.75, y: 0.5)
            gradientlayer.frame = CGRect(x: view.bounds.minX , y: view.bounds.minY, width: view.bounds.size.width , height: view.frame.size.height)
            view.layer.insertSublayer(gradientlayer, at: 0)
        }
    
    func shake(duration: CFTimeInterval) {
        
        let translation = CAKeyframeAnimation(keyPath: "transform.translation.x");
        translation.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.linear)
        translation.values = [-5, 5, -5, 5, -3, 3, -2, 2, 0]
        
        let rotation = CAKeyframeAnimation(keyPath: "transform.rotation.z")
        rotation.values = [-5, 5, -5, 5, -3, 3, -2, 2, 0].map {
            ( degrees: Double) -> Double in
            let radians: Double = (M_PI_2 * degrees) / 180.0
            return radians
        }
        
        let shakeGroup: CAAnimationGroup = CAAnimationGroup()
        shakeGroup.animations = [translation, rotation]
        shakeGroup.duration = duration
        self.layer.add(shakeGroup, forKey: "shakeIt")
    }
    
    
}

//Mark: extension for round two cornor

extension UIView {
    
    func roundCorners(_ corners:UIRectCorner, radius: CGFloat) {
        
        let path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: corners, cornerRadii: CGSize(width: radius, height: radius))
        let mask = CAShapeLayer()
        mask.path = path.cgPath
        self.layer.mask = mask
    }
}

extension UIButton {
    
    func roundCornersButton(_ corners:UIRectCorner, radius: CGFloat) {
        
        let path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: corners, cornerRadii: CGSize(width: radius, height: radius))
        let mask = CAShapeLayer()
        mask.path = path.cgPath
        self.layer.mask = mask
    }
    @IBInspectable var minimumfontsize: CGFloat {
        get {
            return CGFloat(self.titleLabel?.font.pointSize ?? 20)
        }
        set {
            self.titleLabel!.minimumScaleFactor = newValue
            self.titleLabel!.numberOfLines = 0
            self.titleLabel!.adjustsFontSizeToFitWidth = true
        }
    }
}
extension UIButton
{
    var myOwnTag: Int?
    {
        get{
            return 0
        }
        set{
            var propertyVal : Int? = nil
            if let value = newValue{
                propertyVal = value
            }
        }
    }
}


//#MARK: - Extension String

extension String
{
    func trim() -> String
    {
        return self.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
    }
    var length1: Int {
        return self.count
    }
    
    var html2AttributedString: NSAttributedString? {
        guard let data = data(using: .utf8) else { return nil }
        do {
            return  nil
            //return try NSAttributedString(data: data, options: [.documen: NSHTMLTextDocumentType, NSCharacterEncodingDocumentAttribute: String.Encoding.utf8.rawValue], documentAttributes: nil)
        } catch let error as NSError {
            print(error.localizedDescription)
            return  nil
        }
    }
    var html2String: String {
        return html2AttributedString?.string ?? ""
    }
    
    
}

//#MARK: - Extension UIApplication

extension UIApplication {
    var statusBarUIView: UIView? {

      if #available(iOS 13.0, *) {
          let tag = 3848245
          let keyWindow = UIApplication.shared.connectedScenes
              .map({$0 as? UIWindowScene})
              .compactMap({$0})
              .first?.windows.first

          if let statusBar = keyWindow?.viewWithTag(tag) {
              return statusBar
          } else {
              let height = keyWindow?.windowScene?.statusBarManager?.statusBarFrame ?? .zero
              let statusBarView = UIView(frame: height)
              statusBarView.tag = tag
              statusBarView.layer.zPosition = 999999

              keyWindow?.addSubview(statusBarView)
              return statusBarView
          }
      } else {
          if responds(to: Selector(("statusBar"))) {
              return value(forKey: "statusBar") as? UIView
          }
      }
      return nil
    }
}


//#MARK: - Extension TextField Placeholder

extension UITextField{
    
    @IBInspectable var placeHolderColor: UIColor? {
        get {
            return self.placeHolderColor
        }
        set {
            self.attributedPlaceholder = NSAttributedString(string:self.placeholder != nil ? self.placeholder! : "", attributes:[NSAttributedString.Key.foregroundColor: newValue!])
        }
    }
    @IBInspectable var shadowOffsetP: CGSize {
        get {
            return self.layer.shadowOffset
        }
        set {
            self.layer.shadowOffset = newValue
        }
    }
    func lenth()-> Int{
        
        
        return self.text!.count
        
    }
    
    func useUnderline() {
        let border = CALayer()
        let borderWidth = CGFloat(1.0)
        border.borderColor = UIColor.lightGray.cgColor
        border.frame = CGRect(origin: CGPoint(x: 0,y :self.frame.size.height - borderWidth), size: CGSize(width: self.frame.size.width, height: self.frame.size.height))
        border.borderWidth = borderWidth
        self.layer.addSublayer(border)
        self.layer.masksToBounds = true
    }
    
//    @IBInspectable var placeHolderAddStar: UIColor? {
//        get {
//            return self.placeHolderAddStar
//        }
//        set {
//            let passwordAttriburedString = NSMutableAttributedString(string:self.placeholder != nil ? self.placeholder! : "", attributes:[NSAttributedString.Key.foregroundColor: newValue!])
//                
//            let asterix = NSAttributedString(string: "*", attributes: [.foregroundColor: UIColor.red])
//            passwordAttriburedString.append(asterix)
//
//            self.attributedPlaceholder = passwordAttriburedString
//            
//        }
//    }
    
}



//#MARK: - UIViewController

extension UIViewController {
    
    
    
    func hideKeyboardWhenTappedAround() {
        
        let tap: UITapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(UIViewController.dismissKeyboard))
        view.addGestureRecognizer(tap)
    }
    
    @objc func dismissKeyboard() {
        view.endEditing(true)
    }
}

//#MARK: - Double
extension Double {
    var km: Double { return self * 1_000.0 }
    var m: Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
//#MARK: - Image Extension

extension UIImage {
    
    
    func maskWithColor(_ color: UIColor) -> UIImage? {
        let maskImage = cgImage!
        
        let width = size.width
        let height = size.height
        let bounds = CGRect(x: 0, y: 0, width: width, height: height)
        
        let colorSpace = CGColorSpaceCreateDeviceRGB()
        let bitmapInfo = CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedLast.rawValue)
        let context = CGContext(data: nil, width: Int(width), height: Int(height), bitsPerComponent: 8, bytesPerRow: 0, space: colorSpace, bitmapInfo: bitmapInfo.rawValue)!
        
        context.clip(to: bounds, mask: maskImage)
        context.setFillColor(color.cgColor)
        context.fill(bounds)
        
        if let cgImage = context.makeImage() {
            let coloredImage = UIImage(cgImage: cgImage)
            return coloredImage
        } else {
            return nil
        }
    }
    
    
    func resizeImage(image:UIImage, maxHeight:Float, maxWidth:Float) -> UIImage
    {
        var actualHeight:Float = Float(image.size.height)
        var actualWidth:Float = Float(image.size.width)
        
        var imgRatio:Float = actualWidth/actualHeight
        let maxRatio:Float = maxWidth/maxHeight
        
        if (actualHeight > maxHeight) || (actualWidth > maxWidth)
        {
            if(imgRatio < maxRatio)
            {
                imgRatio = maxHeight / actualHeight;
                actualWidth = imgRatio * actualWidth;
                actualHeight = maxHeight;
            }
            else if(imgRatio > maxRatio)
            {
                imgRatio = maxWidth / actualWidth;
                actualHeight = imgRatio * actualHeight;
                actualWidth = maxWidth;
            }
            else
            {
                actualHeight = maxHeight;
                actualWidth = maxWidth;
            }
        }
        
        let rect:CGRect = CGRect(x: 0.0, y: 0.0, width: CGFloat(actualWidth), height: CGFloat(actualHeight))
        UIGraphicsBeginImageContext(rect.size)
        image.draw(in: rect)
        
        let img:UIImage = UIGraphicsGetImageFromCurrentImageContext()!
        let imageData:NSData = img.jpegData(compressionQuality: 1.0)! as NSData
        
//    let imageData:NSData = UIImageJPEGRepresentation(img, 1.0)! as NSData
        UIGraphicsEndImageContext()
        
        return UIImage(data: imageData as Data)!
        
    }
    func resized(withPercentage percentage: CGFloat) -> UIImage? {
        let canvasSize = CGSize(width: size.width * percentage, height: size.height * percentage)
        UIGraphicsBeginImageContextWithOptions(canvasSize, false, scale)
        defer { UIGraphicsEndImageContext() }
        draw(in: CGRect(origin: .zero, size: canvasSize))
        return UIGraphicsGetImageFromCurrentImageContext()
    }

    func resizeWithPercent(percentage: CGFloat) -> UIImage? {
        let imageView = UIImageView(frame: CGRect(origin: .zero, size: CGSize(width: size.width * percentage, height: size.height * percentage)))
        imageView.contentMode = .scaleAspectFit
        imageView.image = self
        UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, false, scale)
        guard let context = UIGraphicsGetCurrentContext() else { return nil }
        imageView.layer.render(in: context)
        guard let result = UIGraphicsGetImageFromCurrentImageContext() else { return nil }
        UIGraphicsEndImageContext()
        return result
    }
  
    
    func resizeByByte(maxMB: Double, completion: @escaping (Data) -> Void) {
        
        var compressQuality: CGFloat = 1
        var imageData = Data()
        let max = maxMB * 1000000.0
        var imageByte = Double(self.jpegData(compressionQuality: 1.0)?.count ?? 0)
        imageData = self.jpegData(compressionQuality: compressQuality)!
                
        while imageByte > max {
            imageData = self.jpegData(compressionQuality: compressQuality)!
            imageByte = Double(imageData.count)
//            imageByte = Double(self.jpegData(compressionQuality: compressQuality)?.count ?? 0)
            compressQuality -= 0.1
        }
        
        if max > imageByte {
            completion(imageData)
        } else {
            completion(self.jpegData(compressionQuality: 1.0)!)
        }
    }
    func resize(withPercentage percentage: CGFloat) -> UIImage? {
        var newRect = CGRect(origin: .zero, size: CGSize(width: size.width*percentage, height: size.height*percentage))
        UIGraphicsBeginImageContextWithOptions(newRect.size, true, 1)
        self.draw(in: newRect)
        defer {UIGraphicsEndImageContext()}
        return UIGraphicsGetImageFromCurrentImageContext()
    }
}

//#MARK:- random color

extension CGFloat {
    static func random() -> CGFloat {
        return CGFloat(arc4random()) / CGFloat(UInt32.max)
    }
}

extension UIColor {
    static var random: UIColor {
        return UIColor(red: .random(), green: .random(), blue: .random(), alpha: 1.0)
    }
}


////#MARK:- ********* Extenstion Device name********
//
//public extension UIDevice {
//    
//    static let modelName: String = {
//        var systemInfo = utsname()
//        uname(&systemInfo)
//        let machineMirror = Mirror(reflecting: systemInfo.machine)
//        let identifier = machineMirror.children.reduce("") { identifier, element in
//            guard let value = element.value as? Int8, value != 0 else { return identifier }
//            return identifier + String(UnicodeScalar(UInt8(value)))
//        }
//        
//        func mapToDevice(identifier: String) -> String { // swiftlint:disable:this cyclomatic_complexity
//            #if os(iOS)
//            switch identifier {
//            case "iPod5,1":                                 return "iPod Touch 5"
//            case "iPod7,1":                                 return "iPod Touch 6"
//            case "iPhone3,1", "iPhone3,2", "iPhone3,3":     return "iPhone 4"
//            case "iPhone4,1":                               return "iPhone 4s"
//            case "iPhone5,1", "iPhone5,2":                  return "iPhone 5"
//            case "iPhone5,3", "iPhone5,4":                  return "iPhone 5c"
//            case "iPhone6,1", "iPhone6,2":                  return "iPhone 5s"
//            case "iPhone7,2":                               return "iPhone 6"
//            case "iPhone7,1":                               return "iPhone 6 Plus"
//            case "iPhone8,1":                               return "iPhone 6s"
//            case "iPhone8,2":                               return "iPhone 6s Plus"
//            case "iPhone9,1", "iPhone9,3":                  return "iPhone 7"
//            case "iPhone9,2", "iPhone9,4":                  return "iPhone 7 Plus"
//            case "iPhone8,4":                               return "iPhone SE"
//            case "iPhone10,1", "iPhone10,4":                return "iPhone 8"
//            case "iPhone10,2", "iPhone10,5":                return "iPhone 8 Plus"
//            case "iPhone10,3", "iPhone10,6":                return "iPhone X"
//            case "iPhone11,2":                              return "iPhone XS"
//            case "iPhone11,4", "iPhone11,6":                return "iPhone XS Max"
//            case "iPhone11,8":                              return "iPhone XR"
//            case "iPad2,1", "iPad2,2", "iPad2,3", "iPad2,4":return "iPad 2"
//            case "iPad3,1", "iPad3,2", "iPad3,3":           return "iPad 3"
//            case "iPad3,4", "iPad3,5", "iPad3,6":           return "iPad 4"
//            case "iPad4,1", "iPad4,2", "iPad4,3":           return "iPad Air"
//            case "iPad5,3", "iPad5,4":                      return "iPad Air 2"
//            case "iPad6,11", "iPad6,12":                    return "iPad 5"
//            case "iPad7,5", "iPad7,6":                      return "iPad 6"
//            case "iPad2,5", "iPad2,6", "iPad2,7":           return "iPad Mini"
//            case "iPad4,4", "iPad4,5", "iPad4,6":           return "iPad Mini 2"
//            case "iPad4,7", "iPad4,8", "iPad4,9":           return "iPad Mini 3"
//            case "iPad5,1", "iPad5,2":                      return "iPad Mini 4"
//            case "iPad6,3", "iPad6,4":                      return "iPad Pro (9.7-inch)"
//            case "iPad6,7", "iPad6,8":                      return "iPad Pro (12.9-inch)"
//            case "iPad7,1", "iPad7,2":                      return "iPad Pro (12.9-inch) (2nd generation)"
//            case "iPad7,3", "iPad7,4":                      return "iPad Pro (10.5-inch)"
//            case "iPad8,1", "iPad8,2", "iPad8,3", "iPad8,4":return "iPad Pro (11-inch)"
//            case "iPad8,5", "iPad8,6", "iPad8,7", "iPad8,8":return "iPad Pro (12.9-inch) (3rd generation)"
//            case "AppleTV5,3":                              return "Apple TV"
//            case "AppleTV6,2":                              return "Apple TV 4K"
//            case "AudioAccessory1,1":                       return "HomePod"
//                //            case "i386", "x86_64":                          return "Simulator \(mapToDevice(identifier: ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"] ?? "iOS"))"
//                
//                
//            case "i386", "x86_64":                          return "\(mapToDevice(identifier: ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"] ?? "iOS"))"
//                
//            default:                                        return identifier
//            }
//            #elseif os(tvOS)
//            switch identifier {
//            case "AppleTV5,3": return "Apple TV 4"
//            case "AppleTV6,2": return "Apple TV 4K"
//            case "i386", "x86_64": return "Simulator \(mapToDevice(identifier: ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"] ?? "tvOS"))"
//            default: return identifier
//            }
//            #endif
//        }
//        
//        return mapToDevice(identifier: identifier)
//    }()
//    
//}



//#MARK:- ********* Extenstion Array********
extension Array {
    
    func randomItem() -> Element {
        let index = Int(arc4random_uniform(UInt32(self.count)))
        return self[index]
    }
    
}
//#MARK:- ********* Extenstion CG POINT********
//extension CGPoint {
//
//    func distance(from point: CGPoint) -> CGFloat {
//        return hypot(point.x - x, point.y - y)
//    }
//
//}
extension String {
    func isEqualToString(find: String) -> Bool {
        return String(format: self) == find
    }
}


//#MARK:- ********* Extenstion UIProgressView ********



extension UIProgressView {
    @IBInspectable var sizeOfPropgress: CGSize {
        get {
            return CGSize(width: 1, height: 1)
        }
        set {
            self.transform = self.transform.scaledBy(x: newValue.width, y: newValue.height)
            self.layer.cornerRadius = 2*newValue.height
            self.clipsToBounds = true
            self.layer.sublayers![1].cornerRadius = newValue.height
            self.subviews[1].clipsToBounds = true
        }
    }
}

extension UITableView {
    
    func setEmptyMessage(_ message: String) {
        let messageLabel = UILabel(frame: CGRect(x: 0, y: 0, width: self.bounds.size.width, height: self.bounds.size.height))
        messageLabel.text = message
        messageLabel.textColor = .black
        messageLabel.numberOfLines = 0
        messageLabel.textAlignment = .center
        messageLabel.font = UIFont(name: "Poppins Medium", size: 17)
        messageLabel.sizeToFit()

        self.backgroundView = messageLabel
        self.separatorStyle = .none
    }
    
    func setEmptyImag(_ message: UIImage) {
//          let messageLabel = UILabel(frame: CGRect(x: 0, y: 0, width: self.bounds.size.width, height: self.bounds.size.height))
        let messageLabel = UIImageView(frame: CGRect(x: self.center.x, y: center.y, width: self.bounds.size.width, height: self.bounds.size.height))
//          messageLabel.text = message
//          messageLabel.textColor = .black
//          messageLabel.numberOfLines = 0
//          messageLabel.textAlignment = .center
//          messageLabel.font = UIFont(name: AppFonts.Bebas_Neue_Pro_Book.rawValue, size: 15)
          messageLabel.image = message
//          messageLabel.sizeToFit()
          messageLabel.contentMode = .scaleAspectFit

          self.backgroundView = messageLabel
          self.separatorStyle = .none
      }

    func restore() {
        self.backgroundView = nil
        self.separatorStyle = .none
    }

}

extension UICollectionView {

    func setEmptyMessage(_ message: String,_ img:UIImage) {

//        let image = UIImageView()
//        image.contentMode = .center//.scaleAspectFit
//        image.image = img
//
//
//        let messageLabel = UILabel()
//        messageLabel.text = message
//        messageLabel.font = UIFont(name: "Poppins Medium", size: 17)
//        messageLabel.textColor = .black
//        messageLabel.numberOfLines = 0
//        messageLabel.textAlignment = .center
//        messageLabel.sizeToFit()
//
//        let mainView = UIView()
//        mainView.addSubview(image)
//        mainView.addSubview(messageLabel)
//
//        //Auto Layout
//        image.translatesAutoresizingMaskIntoConstraints = false
//        image.centerXAnchor.constraint(equalTo: mainView.centerXAnchor).isActive = true
//        image.centerYAnchor.constraint(equalTo: mainView.centerYAnchor , constant: -120).isActive = true
//
//        messageLabel.translatesAutoresizingMaskIntoConstraints = false
//        messageLabel.topAnchor.constraint(equalTo: image.bottomAnchor, constant: 20).isActive = true
//        messageLabel.leadingAnchor.constraint(equalTo: mainView.leadingAnchor, constant: 10).isActive = true
//        messageLabel.trailingAnchor.constraint(equalTo: mainView.trailingAnchor, constant: -15).isActive = true
//
//        self.backgroundView = mainView
        
        let messageLabel = UILabel(frame: CGRect(x: 0, y: 0, width: self.bounds.size.width, height: self.bounds.size.height))
               messageLabel.text = message
               messageLabel.textColor = .black
               messageLabel.numberOfLines = 0
               messageLabel.textAlignment = .center
               messageLabel.font = UIFont(name: "Poppins Medium", size: 17) // Set your font type
               messageLabel.sizeToFit()
               
               self.backgroundView = messageLabel;
    }

    func restoreBackgroundView() {
        self.backgroundView = nil
    }
}
//

class CurvedView: UIView {
     func drawRect(rect: CGRect) {

        let y:CGFloat = 20
        let curveTo:CGFloat = 0

        let myBezier = UIBezierPath()
        myBezier.move(to: CGPoint(x: 0, y: y))
        myBezier.addQuadCurve(to: CGPoint(x: rect.width, y: y), controlPoint: CGPoint(x: rect.width / 2, y: curveTo))
        myBezier.addLine(to: CGPoint(x: rect.width, y: rect.height))
        myBezier.addLine(to: CGPoint(x: 0, y: rect.height))
        myBezier.close()
        let context = UIGraphicsGetCurrentContext()
        context!.setLineWidth(4.0)
        UIColor.white.setFill()
        myBezier.fill()
    }
}

extension UIView {

    func addTopRoundedCornerToView(targetView:UIView?, desiredCurve:CGFloat?)
    {
        let offset:CGFloat =  targetView!.frame.width/desiredCurve!
        let bounds: CGRect = targetView!.bounds

        let rectBounds: CGRect = CGRect(x: bounds.origin.x, y: bounds.origin.y+bounds.size.height / 2, width: bounds.size.width, height: bounds.size.height)

        let rectPath: UIBezierPath = UIBezierPath(rect: rectBounds)
        let ovalBounds: CGRect = CGRect(x: bounds.origin.x - offset / 2, y: bounds.origin.y, width: bounds.size.width + offset, height: bounds.size.height)
        print(ovalBounds)
        let ovalPath: UIBezierPath = UIBezierPath(ovalIn: ovalBounds)
        rectPath.append(ovalPath)

        // Create the shape layer and set its path
        let maskLayer: CAShapeLayer = CAShapeLayer()
        maskLayer.frame = bounds
        maskLayer.path = rectPath.cgPath

        // Set the newly created shape layer as the mask for the view's layer
        targetView!.layer.mask = maskLayer
    }
}
@IBDesignable class BubbleView: UIView { // 1

  override init(frame: CGRect) { // 2
    super.init(frame: frame)
    
    commonInit()
  }
  
  required init?(coder: NSCoder) {
    super.init(coder: coder)
    
    commonInit()
  }
  
  private func commonInit() {
    super.backgroundColor = .clear // 3
  }
  
  private var bubbleColor: UIColor? { // 4
    didSet {
      setNeedsDisplay() // 5
    }
  }
  
  override var backgroundColor: UIColor? { // 6
    get { return bubbleColor }
    set { bubbleColor = newValue }
  }
    enum ArrowDirection: String { // 1
        case left = "left"
        case right = "right"
      }

      var arrowDirection: ArrowDirection = .right { // 2
        didSet {
          setNeedsDisplay()
        }
      }

      @IBInspectable var arrowDirectionIB: String { // 3
        get {
          return arrowDirection.rawValue
        }
        set {
          if let direction = ArrowDirection(rawValue: newValue) {
            arrowDirection = direction
          }
        }
      }
  override func draw(_ rect: CGRect) { // 7
    let bezierPath = UIBezierPath() // 8

      bezierPath.lineWidth = borderWidth // 3
         
        let bottom = rect.height - borderWidth // 4
         let right = rect.width - borderWidth
         let top = borderWidth
         let left = borderWidth
      
      if arrowDirection == .right { // 4
                bezierPath.move(to: CGPoint(x: right - 22, y: bottom)) // 5
                    bezierPath.addLine(to: CGPoint(x: 17 + borderWidth, y: bottom))
                    bezierPath.addCurve(to: CGPoint(x: left, y: bottom - 18), controlPoint1: CGPoint(x: 7.61 + borderWidth, y: bottom), controlPoint2: CGPoint(x: left, y: bottom - 7.61))
                    bezierPath.addLine(to: CGPoint(x: left, y: 17 + borderWidth))
                    bezierPath.addCurve(to: CGPoint(x: 17 + borderWidth, y: top), controlPoint1: CGPoint(x: left, y: 7.61 + borderWidth), controlPoint2: CGPoint(x: 7.61 + borderWidth, y: top))
                    bezierPath.addLine(to: CGPoint(x: right - 21, y: top))
                    bezierPath.addCurve(to: CGPoint(x: right - 4, y: 17 + borderWidth), controlPoint1: CGPoint(x: right - 11.61, y: top), controlPoint2: CGPoint(x: right - 4, y: 7.61 + borderWidth))
                    bezierPath.addLine(to: CGPoint(x: right - 4, y: bottom - 11))
                    bezierPath.addCurve(to: CGPoint(x: right, y: bottom), controlPoint1: CGPoint(x: right - 4, y: bottom - 1), controlPoint2: CGPoint(x: right, y: bottom))
                    bezierPath.addLine(to: CGPoint(x: right + 0.05, y: bottom - 0.01))
                    bezierPath.addCurve(to: CGPoint(x: right - 11.04, y: bottom - 4.04), controlPoint1: CGPoint(x: right - 4.07, y: bottom + 0.43), controlPoint2: CGPoint(x: right - 8.16, y: bottom - 1.06))
                    bezierPath.addCurve(to: CGPoint(x: right - 22, y: bottom), controlPoint1: CGPoint(x: right - 16, y: bottom), controlPoint2: CGPoint(x: right - 19, y: bottom))
                    bezierPath.close()
          } else {
            bezierPath.move(to: CGPoint(x: 22 + borderWidth, y: bottom)) // 5
            bezierPath.addLine(to: CGPoint(x: right - 17, y: bottom))
            bezierPath.addCurve(to: CGPoint(x: right, y: bottom - 17), controlPoint1: CGPoint(x: right - 7.61, y: bottom), controlPoint2: CGPoint(x: right, y: bottom - 7.61))
            bezierPath.addLine(to: CGPoint(x: right, y: 17 + borderWidth))
            bezierPath.addCurve(to: CGPoint(x: right - 17, y: top), controlPoint1: CGPoint(x: right, y: 7.61 + borderWidth), controlPoint2: CGPoint(x: right - 7.61, y: top))
            bezierPath.addLine(to: CGPoint(x: 21 + borderWidth, y: top))
            bezierPath.addCurve(to: CGPoint(x: 4 + borderWidth, y: 17 + borderWidth), controlPoint1: CGPoint(x: 11.61 + borderWidth, y: top), controlPoint2: CGPoint(x: borderWidth + 4, y: 7.61 + borderWidth))
            bezierPath.addLine(to: CGPoint(x: borderWidth + 4, y: bottom - 11))
            bezierPath.addCurve(to: CGPoint(x: borderWidth, y: bottom), controlPoint1: CGPoint(x: borderWidth + 4, y: bottom - 1), controlPoint2: CGPoint(x: borderWidth, y: bottom))
            bezierPath.addLine(to: CGPoint(x: borderWidth - 0.05, y: bottom - 0.01))
            bezierPath.addCurve(to: CGPoint(x: borderWidth + 11.04, y: bottom - 4.04), controlPoint1: CGPoint(x: borderWidth + 4.07, y: bottom + 0.43), controlPoint2: CGPoint(x: borderWidth + 8.16, y: bottom - 1.06))
            bezierPath.addCurve(to: CGPoint(x: borderWidth + 22, y: bottom), controlPoint1: CGPoint(x: borderWidth + 16, y: bottom), controlPoint2: CGPoint(x: borderWidth + 19, y: bottom))
          }

    
    backgroundColor?.setFill() // 9
    bezierPath.fill()
    bezierPath.stroke()
  }
    
}

extension UIViewController{
    func isImage(data: Data) -> Bool {
        let imageMagicNumbers: Set<Data> = [
            Data([0xFF, 0xD8, 0xFF]),  // JPEG
            Data([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]),  // PNG
            Data([0x47, 0x49, 0x46, 0x38, 0x37, 0x61]),  // GIF
            Data([0x47, 0x49, 0x46, 0x38, 0x39, 0x61]),  // GIF
            Data([0x42, 0x4D]),  // BMP
            Data([0x49, 0x49, 0x2A, 0x00]),  // TIFF
            Data([0x4D, 0x4D, 0x00, 0x2A]),  // TIFF
            Data([0x00, 0x00, 0x01, 0x00]),  // ICO
            Data([0x00, 0x00, 0x02, 0x00]),  // ICO
            Data([0x42, 0x50, 0x47, 0xFB]),  // WebP
            // Add more magic numbers for other image formats if needed
        ]
        
        return imageMagicNumbers.contains(data.prefix(imageMagicNumbers.first!.count))
    }
    
    func isPDF(data: Data) -> Bool {
        let pdfMagicNumber: Data = Data([0x25, 0x50, 0x44, 0x46])  // PDF
        
        return data.prefix(pdfMagicNumber.count) == pdfMagicNumber
    }
    
    func isMicrosoftWord(data: Data) -> Bool {
        let docMagicNumbers: Set<Data> = [
            Data([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1]),  // DOC
            Data([0x50, 0x4B, 0x03, 0x04]),  // DOCX
        ]
        return docMagicNumbers.contains(data.prefix(docMagicNumbers.first!.count))
    }
}

 

class GradientLabel: UILabel {
    var gradientColors: [CGColor] = []

    override func drawText(in rect: CGRect) {
        if let gradientColor = drawGradientColor(in: rect, colors: gradientColors) {
            self.textColor = gradientColor
        }
        super.drawText(in: rect)
    }

    private func drawGradientColor(in rect: CGRect, colors: [CGColor]) -> UIColor? {
        let currentContext = UIGraphicsGetCurrentContext()
        currentContext?.saveGState()
        defer { currentContext?.restoreGState() }

        let size = rect.size
        UIGraphicsBeginImageContextWithOptions(size, false, 0)
        guard let gradient = CGGradient(colorsSpace: CGColorSpaceCreateDeviceRGB(),
                                        colors: colors as CFArray,
                                        locations: nil) else { return nil }

        let context = UIGraphicsGetCurrentContext()
        context?.drawLinearGradient(gradient,
                                    start: CGPoint.zero,
                                    end: CGPoint(x: 0, y: size.height),
                                    options: [])
        let gradientImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        guard let image = gradientImage else { return nil }
        return UIColor(patternImage: image)
    }
}
 

//extension UITextView {
//
//    private class PlaceholderLabel: UILabel { }
//
//    private var placeholderLabel: PlaceholderLabel {
//        if let label = subviews.compactMap( { $0 as? PlaceholderLabel }).first {
//
//            return label
//        } else {
//            let label = PlaceholderLabel(frame: .zero)
//            label.font = font
//            addSubview(label)
//            return label
//        }
//
//    }
//
////    @IBInspectable
////    var placeholder: String {
////        get {
////            return subviews.compactMap( { $0 as? PlaceholderLabel }).first?.text ?? ""
////        }
////        set {
////            let placeholderLabel = self.placeholderLabel
////            placeholderLabel.text = newValue
////            placeholderLabel.numberOfLines = 0
////            let width = frame.width - textContainer.lineFragmentPadding * 2
////            let size = placeholderLabel.sizeThatFits(CGSize(width: width, height: .greatestFiniteMagnitude))
////            placeholderLabel.frame.size.height = size.height
////            placeholderLabel.frame.size.width = width
////            placeholderLabel.frame.origin = CGPoint(x: textContainer.lineFragmentPadding, y: textContainerInset.top)
////
////            textStorage.delegate = self
////        }
////    }
//
//}

//extension UITextView: NSTextStorageDelegate {
//
//    public func textStorage(_ textStorage: NSTextStorage, didProcessEditing editedMask: NSTextStorage.EditActions, range editedRange: NSRange, changeInLength delta: Int) {
//        if editedMask.contains(.editedCharacters) {
//            placeholderLabel.isHidden = !text.isEmpty
//        }
//    }
//
//}

//extension UIViewController{
//    func checkCamera() {
//        let authStatus = AVCaptureDevice.authorizationStatus(for: AVMediaType.video)
//        switch authStatus {
//        case .authorized: break//callCamera() // Do your stuff here i.e. callCameraMethod()
//        case .denied: alertPromptToAllowCameraAccessViaSetting()
//        case .notDetermined: alertToEncourageCameraAccessInitially()
//        default: alertToEncourageCameraAccessInitially()
//        }
//    }
//
//    func alertToEncourageCameraAccessInitially() {
//        let alert = UIAlertController(
//            title: "IMPORTANT",
//            message: "Camera access required for capturing photos!",
//            preferredStyle: UIAlertController.Style.alert
//        )
//        alert.addAction(UIAlertAction(title: "Cancel", style: .default, handler: nil))
//        alert.addAction(UIAlertAction(title: "Allow Camera", style: .cancel, handler: { (alert) -> Void in
//            UIApplication.shared.openURL(URL(string: UIApplication.openSettingsURLString)!)
//        }))
//        present(alert, animated: true, completion: nil)
//    }
//
//    func alertPromptToAllowCameraAccessViaSetting() {
//
//        let alert = UIAlertController(
//            title: "IMPORTANT",
//            message: "Camera access required for capturing photos!",
//            preferredStyle: UIAlertController.Style.alert
//        )
//        alert.addAction(UIAlertAction(title: "Dismiss", style: .cancel) { alert in
//            if AVCaptureDevice.devices(for: AVMediaType.video).count > 0 {
//                AVCaptureDevice.requestAccess(for: AVMediaType.video) { granted in
//                    DispatchQueue.main.async() {
//                        self.checkCamera() } }
//            }
//            }
//        )
//        present(alert, animated: true, completion: nil)
//    }
//}

extension UIViewController{
    func convertImageToBase64(image: UIImage, compressionQuality: CGFloat = 1.0) -> String? {
        // Convert image to JPEG data with the specified compression quality
        guard let imageData = image.jpegData(compressionQuality: compressionQuality) else {
            print("Failed to convert image to JPEG data.")
            return nil
        }
        // Convert image data to a Base64 encoded string
        let base64 =  imageData.base64EncodedString(options: Data.Base64EncodingOptions.lineLength64Characters)
                              
        let base64String = base64.replacingOccurrences(of: "\r\n", with: "")
        return base64String
    }
    
    func roundedFormattedValue(_ value: Double, decimalPlaces: Int) -> String {
        let factor = pow(10.0, Double(decimalPlaces))
        let roundedValue = round(value * factor) / factor

        // Format based on value type
        if roundedValue.truncatingRemainder(dividingBy: 1) == 0 {
            // Whole number
            return String(format: "%.0f", roundedValue)
        } else {
            // Fractional number (trim trailing zeros)
            return String(format: "%g", roundedValue)
        }
    }
    
    func formatPrice(_ netTotal: Double) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.minimumFractionDigits = 0
        formatter.maximumFractionDigits = 2
        
        return formatter.string(from: NSNumber(value: netTotal)) ?? "\(netTotal)"
    }
    
    
    func formatQuantity(_ qnty: String) -> String {
        guard let quantity = Double(qnty) else {
            return "Invalid input"
        }
        
        // Format to show 1 digit after the decimal point
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.maximumFractionDigits = 1
        formatter.minimumFractionDigits = 0
        
        if let formattedString = formatter.string(from: NSNumber(value: quantity)) {
            return formattedString
        }
        
        return qnty
    }
}
 
extension Double {
    func roundedTo(places: Int) -> Double {
        let multiplier = pow(10.0, Double(places))
        return (self * multiplier).rounded() / multiplier
    }
}


extension UIImage{
    func convertToGrayscale(image: UIImage) -> UIImage? {
        guard let ciImage = CIImage(image: image) else { return nil }
        let grayscaleFilter = CIFilter(name: "CIPhotoEffectMono")
        grayscaleFilter?.setValue(ciImage, forKey: kCIInputImageKey)
        guard let outputCIImage = grayscaleFilter?.outputImage else { return nil }
        let context = CIContext()
        guard let cgImage = context.createCGImage(outputCIImage, from: outputCIImage.extent) else { return nil }
        return UIImage(cgImage: cgImage)
    }
}
